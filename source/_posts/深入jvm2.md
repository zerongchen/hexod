---
title: java
date: 2019-06-05 00:20:42
tags:jvm 之 java 类加载
---
# jvm中的类加载
java中有两大类型：基础类型和引用类型（其中基础类型是上篇中的八大基础类型）

本文主要讲引用类型（类，接口，数组类，泛型参数），而泛型参数最终在编译过程中会被擦除，所以实际上是前三，而数组类是在java虚拟机生成的，正常有专门字节码的是类和接口。java变异成class文件之后，从class必须加载到内存中才能被jvm程序执行，其中经过三大步骤 加载 -> 链接 -> 初始化 。下面围绕着三大步骤展开

## 加载
加载，其实就jvm加载字节流的过程。java虚拟机借用类加载器加载字节流的过程。
常用类加载有：

启动类加载器（native方法，没有对应的java类，故采用null表示），启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类，以及由虚拟机参数 -Xbootclasspath 指定的类。

其他类加载器继承自java.lang.ClassLoader，均由java核心类提供。如：
扩展类加载器（extension class loader，）扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。
应用类加载器（application class loader ）应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

同一个字节流经经过不同的类加载加载后是两个不同的类，这一特性经常用在运行同一个类的不同版本；

双亲委派模型。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。这个是java加载类的模式

## 链接
链接指创建完的类合并至java虚拟机中，使之能够执行的过程，他可以分为验证（验证类符合java类越苏），准备（静态字段分配内存，初始化静态字段），解析(正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载)

## 初始化

所有的静态字段，方法，代码块，以及final修饰的修饰的直接赋值都会置于一个方法中< clinit > ，
Java 虚拟机会通过加锁来确保类的 < clinit > 
### 以下是java类初始化的一些规则
当虚拟机启动时，初始化用户指定的主类；

当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；

当遇到调用静态方法的指令时，初始化该静态方法所在的类；

当遇到访问静态字段的指令时，初始化该静态字段所在的类；

子类的初始化会触发父类的初始化；

如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；

使用反射 API 对某个类进行反射调用时，初始化这个类；

当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。


可以通过 JVM 参数 -verbose:class 来打印类加载的先后顺序，初始化先后，-XX：+TraceClassLoading打印类的加载过程



