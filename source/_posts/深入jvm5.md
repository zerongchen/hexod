---
title: 深入jvm5.md
date: 2019-06-18 23:32:16
tags:
---
#java 内存模型
java内存模型的定义决定了java数据操作的顺序性和准确性，程序上讲，因为操作系统的差异性，导致了程序操作内存的差异性，java内存模型的定义也保证了应用层和物理层面的隔离。

###java内存模型目的：
是为了保证程序变量访问规则，即在虚拟中中保存变量->变量从内存中取出来的底层细节等一系列访问规则。【变量】：指程序中的公共变量，实例，静态字段，静态反复，构成数组的对象（不包含局部变量等线程私有变量）。

### java内存规定：
所有变量存在主内存中。与之对应的是各个线程也有相对应的工作内存。每个线程工作的时候，如果访问到主内存的变量，会将该对象的主内存副本拷贝到工作内存中（只拷贝访问字段）。线程对变量的操作都是基于工作内存的，之后再同步到主内存中去。这里的主内存和工作内存和虚拟机的内存分配不是同一个层次的分层，没有可比性。如果非要对应的话可以理解为主内存区是指 堆空间，方法区（代码块和静态变量，常量池）；工作内存指：线程栈帧；

### java内存的交互：
lock，unlock,read,load,use,assign.store,write。所有针对于内存大操作都是成对出现的，没有单独存在的说法比如：lock && unlock , read && load && use, store && wirte;

### java内存模型的3个特征：
原子性

可见性

有序性

###java内存模型原则
#### happen-before 原则
程序次序规则

管程锁定

volatile

程序启动

程序终止

程序终端

程序对象终结

传递性


## volatile型变量
volatile 之所有能够起到及时属刷新主内的数据，保证写操作和读操作的顺序正确性，禁止指令重排，主要是volatile 变量的操作回引入 “内存屏障” ， 内存屏障会在java转为字节码的时候插入一条内存屏障语句。当程序执行到内存屏障时默认程序之前的操作都是完成了的，立马内存同步，从而保证了数据的可见性和重拍的限制。

## remark
64位虚拟中操作long Double等64位变量时，保存的都是32高位和低位保存，这样子long，Double就不是原子操作了，就会出现一个意料之外的数值。但是在现有的虚拟账号不会有这个问题，只要原因是引入了 monitorenter 和 monitorexit  指令。这两种指令均会消耗操作数栈上的一个引用类型的元素，来确保long Double操作时加锁
  