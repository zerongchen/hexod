---
title: 深入jvm7
date: 2019-06-20 23:46:39
tags:
---

即时编译-直接将Java字节码编译成机器码，运行在底层硬件之上，这么玩是为了提高代码的执行效率，通俗点就是能使代码跑的更快一些

即时编译的触发点是热点代码，即 即时编译仅针对热点代码来触发，热点代码是通过方法的调用次数或者回边循环的次数来标示的，这里也侧面反映出来即时编译是针对方法块的


java虚拟机包含多个编译器 C1 C2 Graal
其中Graal是试验性的编译器

jdk7 之前  C1 和 C2 分别用 -client -server来制定C1 C2 的编译器

JDK7 之后引入分层编译的概念

0 ： 解释执行
1 ： 执行无 profiling 的C1代码
2 ： 执行仅带方法调用次数以及循环回边执行次数profiling的代码
3 ： 执行所有带profiling的C1代码
4 ： 执行所有C2代码

在 5 个层次的执行状态中，1 层和 4 层为终止状态

java 8 之后是默认开启分层编译的

通常情况下，方法会首先被解释执行，然后被 3 层的 C1 编译，最后被 4 层的 C2 编译。

即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈值是根据当前待编译的方法数目动态调整的。


##2 
今天我介绍了 Java 虚拟机的 profiling 以及基于所收集的数据的优化和去优化。

通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。

当方法被 3 层 C1 所编译时，生成的 C1 代码将收集条件跳转指令的分支 profile，以及类型相关指令的类型 profile。在部分极端情况下，Java 虚拟机也会在解释执行过程中收集这些 profile。

基于分支 profile 的优化以及基于类型 profile 的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java 虚拟机将采取去优化，退回至解释执行并重新收集相关的 profile